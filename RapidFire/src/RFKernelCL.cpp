//
// Copyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Kernels to run CSC
// 
// const int4 vDim conatins the dimension of the image
//      vDim.x = width  of input image
//      vDim.y = height of input image
//      vDim.z = Aligned width  of output buffer
//      vDim.w = Aligned height of output buffer
//      Since the output of the CSC is sent to an encoder there might be restrictions on the 
//      image size. Those are represented in the aligned width and aligned height.
//
// const int isOpenGLObj
//      if true, the CSC will mirror the result
//
// const int nTargetOrdering
//      specifies the channel ordering. The followong values are accepted
//      0: RGBA
//      1: ARGB
//      2: BGRA
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////



const char* str_cl_kernels =
    "\n"
    "__constant sampler_t imageSampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP | CLK_FILTER_NEAREST;\n"
    "\n"
    "// The dimension is based on the chroma planes. Since we use a YUV 420 format the chroma plane\n"
    "// is only 1/4 of the size of the Y Plane.\n"
    "// E.g. a 1280x720 input image has a 640x360 dimension \n"
    "//\n"
    "// Global work size is width/2, height/2. Each workitem computes 4 pixels\n"
    "//\n"
    "\n"
    "\n"
    "\n"
    "__kernel void rgbaTonv12_image2d(read_only image2d_t pIn, __global uchar * pOut, const int4 vDim, const int mirror)\n"
    "{\n"
    "    uint uiGlobalIdX = get_global_id(0);    // 0 - width /2\n"
    "    uint uiGlobalIdY = get_global_id(1);    // 0 - height/2\n"
    "\n"
    "    if(uiGlobalIdX >= vDim.x / 2 || uiGlobalIdY >= vDim.y / 2)\n"
    "        return;\n"
    "\n"
    "    // Calculate the offset into Y Plane and into the RGBA buffer. The Y Plane and the RGBA\n"
    "    // buffer have the dimension width x height. The Kernel dimension is only (width/2) x (height / 2)\n"
    "    // which corresponds to the chroma plane dimension. \n"
    "    // Each WorkItem needs to write 4 Luminance samples and one chroma \n"
    "\n"
    "    // Offset to the start of the chroma u-plane\n"
    "    uint uPlaneOffset = vDim.z * vDim.y;\n"
    "\n"
    "    // Offset into the Y Plane. The Y Plane contains 1 Byte data but since each work item computes\n"
    "    // 2x2 pixels, the offset for the first 2 pixels is multiplied by 2\n"
    "    uint uiYPlaneOffset = (uiGlobalIdX + uiGlobalIdY * vDim.z) << 1;\n"
    "\n"
    "    // The FBO contains the pixel in inverted order. The pixel of the lower left corner is stored\n"
    "    // at id 0, so we need to read the buffer starting at the top.\n"
    "\n"
    "    uchar4 RGBA1, RGBA2, RGBA3, RGBA4;\n"
    "\n"
    "    // Read (x,y)\n"
    "    int2 pos = (int2)(uiGlobalIdX * 2, (mirror == 1) ? (vDim.y - 2*uiGlobalIdY-1) : 2*uiGlobalIdY);\n"
    "    RGBA1 = convert_uchar4_sat_rte(255 * read_imagef(pIn, imageSampler, pos));\n"
    "    // Read (x+1, y)\n"
    "    pos.x += 1;\n"
    "    RGBA2 = convert_uchar4_sat_rte(255 * read_imagef(pIn, imageSampler, pos));\n"
    "\n"
    "    // Switch to next row\n"
    "    // Read (x, y+1)\n"
    "    pos = (int2)(uiGlobalIdX * 2, (mirror == 1) ? (vDim.y - uiGlobalIdY * 2 - 2) : (uiGlobalIdY * 2 + 1));\n"
    "    RGBA3 = convert_uchar4_sat_rte(255 * read_imagef(pIn, imageSampler, pos));\n"
    "    // Read (x+1, y+1)\n"
    "    pos.x += 1;\n"
    "    RGBA4 = convert_uchar4_sat_rte(255 * read_imagef(pIn, imageSampler, pos));\n"
    "\n"
    "    ushort4 RGBA = convert_ushort4(RGBA1) + convert_ushort4(RGBA2) + convert_ushort4(RGBA3) + convert_ushort4(RGBA4);\n"
    "    \n"
    "    // Take average color\n"
    "    RGBA = RGBA>>2;\n"
    "\n"
    "    uchar Y1 = ( (  66 * RGBA1.x + 129 * RGBA1.y +  25 * RGBA1.z + 128) >> 8) +  16;\n"
    "    uchar Y2 = ( (  66 * RGBA2.x + 129 * RGBA2.y +  25 * RGBA2.z + 128) >> 8) +  16;\n"
    "    uchar Y3 = ( (  66 * RGBA3.x + 129 * RGBA3.y +  25 * RGBA3.z + 128) >> 8) +  16;\n"
    "    uchar Y4 = ( (  66 * RGBA4.x + 129 * RGBA4.y +  25 * RGBA4.z + 128) >> 8) +  16;\n"
    "    \n"
    "    // Write Y Plane\n"
    "    pOut[uiYPlaneOffset]     = Y1;\n"
    "    pOut[uiYPlaneOffset + 1] = Y2;\n"
    "\n"
    "    uiYPlaneOffset += vDim.z;\n"
    "\n"
    "    pOut[uiYPlaneOffset]     = Y3;\n"
    "    pOut[uiYPlaneOffset + 1] = Y4;\n"
    "\n"
    "    // Write U Plane\n"
    "    pOut[uPlaneOffset + 2*uiGlobalIdX + uiGlobalIdY * vDim.z] = ( ( -38 * RGBA.x -  74 * RGBA.y + 112 * RGBA.z + 128) >> 8) + 128; \n"
    "    // Write V Plane\n"
    "    pOut[uPlaneOffset + 2*uiGlobalIdX + 1 + uiGlobalIdY * vDim.z] = ( ( 112 * RGBA.x -  94 * RGBA.y -  18 * RGBA.z + 128) >> 8) + 128;\n"
    "}\n"
    "\n"
    "\n"
    "\n"
    "__kernel void rgbaToNV12_Planes(__read_only image2d_t rgbaIn, __write_only image2d_t yOut, const int4 vDim, const int mirror, __write_only image2d_t uvOut)\n"
    "{\n"
    "   uint uiGlobalId_X = get_global_id(0);\n"
    "   uint uiGlobalId_Y = get_global_id(1);\n"
    "\n"
    "   // Offset into RGBA source buffer\n"
    "   int2 SrcCoord = (int2)(uiGlobalId_X * 2, (mirror == 1) ? (vDim.y - 2*uiGlobalId_Y-1) : 2*uiGlobalId_Y);  \n"
    "   int2 DstCoord = (int2)( (uiGlobalId_X * 2), (uiGlobalId_Y * 2));\n"
    "\n"
    "   float4 Y, U, V, R, G, B;\n"
    "\n"
    "   float4 pixel = read_imagef(rgbaIn, imageSampler, SrcCoord);\n"
    "\n"
    "   R.x = pixel.x; \n"
    "   G.x = pixel.y; \n"
    "   B.x = pixel.z; \n"
   "\n"
    "   pixel = read_imagef(rgbaIn, imageSampler, (int2)(SrcCoord.x + 1, SrcCoord.y));\n"
    "\n"
    "   R.y = pixel.x; \n"
    "   G.y = pixel.y; \n"
    "   B.y = pixel.z; \n"
    "\n"
    "   SrcCoord.y = (mirror == 1) ? (vDim.y - uiGlobalId_Y * 2 - 2) : (uiGlobalId_Y * 2 + 1); \n"
    "\n"
    "   pixel = read_imagef(rgbaIn, imageSampler, (int2)(SrcCoord.x, SrcCoord.y));\n"
    "\n"
    "   R.z = pixel.x; \n"
    "   G.z = pixel.y; \n"
    "   B.z = pixel.z; \n"
    "\n"
    "   pixel = read_imagef(rgbaIn, imageSampler, (int2)(SrcCoord.x + 1, SrcCoord.y));\n"
    "\n"
    "   R.w = pixel.x; \n"
    "   G.w = pixel.y; \n"
    "   B.w = pixel.z; \n"
    "\n"
    "   Y = (66.0f * R + 129.0f * G + 25.0f * B) + 16.0f;\n"
    "\n"
    "   // Calculate the chroma values for each of the 4 pixels.\n"
    "   U = (-38.0f * R - 74.0f * G + 112.0f * B) + (float4)(128.0f);\n"
    "   V = (112.0f * R - 94.0f * G -  18.0f * B) + (float4)(128.0f);\n"
    "\n"
    "   // Write Y plane. Y range is 0..255\n"
    "   write_imageui(yOut, DstCoord,                               (uint4)((uchar)(Y.x), 0, 0, 0));\n"
    "   write_imageui(yOut, (int2)(DstCoord.x + 1, DstCoord.y    ), (uint4)((uchar)(Y.y), 0, 0, 0));\n"
    "   write_imageui(yOut, (int2)(DstCoord.x    , DstCoord.y + 1), (uint4)((uchar)(Y.z), 0, 0, 0));\n"
    "   write_imageui(yOut, (int2)(DstCoord.x + 1, DstCoord.y + 1), (uint4)((uchar)(Y.w), 0, 0, 0));\n"
    "\n"
    "   // Set image coordinates to be used to write the Chroma plane\n"
    "   DstCoord.x = uiGlobalId_X;\n"
    "   DstCoord.y = uiGlobalId_Y;\n"
    "\n"
    "   // store the average of U and V interleaved in the uv iamge U,V range is 0..255\n"
    "   write_imageui(uvOut, DstCoord, convert_uint4_sat((uchar4)((U.x + U.y + U.z + U.w) / 4.0f, (V.x + V.y + V.z + V.w) / 4.0f, 0.0f, 0.0f)));\n"
    "}\n"
    "\n"
    "\n"
    "\n"
    "\n"
    "\n"
    "__kernel void rgbaToI420_image2d(read_only image2d_t pIn, __global uchar* pOutI420, const int4 vDim, const int mirror)\n"
    "{\n"
    "    uint uiGlobalIdX = get_global_id(0);    // 0 - width /2\n"
    "    uint uiGlobalIdY = get_global_id(1);    // 0 - height/2\n"
    "\n"
    "    if(uiGlobalIdX >= vDim.x / 2 || uiGlobalIdY >= vDim.y / 2)\n"
    "        return;\n"
    "\n"
    "    // Calculate the offset into Y Plane and into the RGBA buffer. The Y Plane and the RGBA\n"
    "    // buffer have the dimension width x height. The Kernel dimension is only (width/2) x (height / 2)\n"
    "    // which corresponds to the chroma plane dimension. \n"
    "    // Each WorkItem needs to write 4 luminance samples and one chroma \n"
    "\n"
    "    // Offset into the Y Plane. The Y Plane contains 1 Byte data but since each work item computes\n"
    "    // 2x2 pixels, the offset for the first 2 pixels is multiplied by 2\n"
    "    uint uiYPlaneOffset = (uiGlobalIdX + uiGlobalIdY * vDim.z) << 1;\n"
    "    \n"
    "    // OpenGL FBO contains the pixel in inverted order. The pixel of the lower left corner is stored\n"
    "    // at id 0, so we need to read the buffer starting at the top.\n"
    "\n"
    "    uchar4 RGBA1, RGBA2, RGBA3, RGBA4;\n"
    "\n"
    "    // Read (x,y)\n"
    "    int2 pos = (int2)(uiGlobalIdX * 2, (mirror == 1) ? (vDim.y - uiGlobalIdY*2-1) : uiGlobalIdY*2);\n"
    "    RGBA1 = convert_uchar4_sat_rte(255 * read_imagef(pIn, imageSampler, pos));\n"
    "    // Read (x+1, y)\n"
    "    pos.x += 1;\n"
    "    RGBA2 = convert_uchar4_sat_rte(255 * read_imagef(pIn, imageSampler, pos));\n"
    "\n"
    "    // Switch to next row\n"
    "    // Read (x, y+1)\n"
    "    pos = (int2)(uiGlobalIdX * 2, (mirror == 1) ? (vDim.y - uiGlobalIdY * 2 - 2) : (uiGlobalIdY * 2 + 1));\n"
    "    RGBA3 = convert_uchar4_sat_rte(255 * read_imagef(pIn, imageSampler, pos));\n"
    "    // Read (x+1, y+1)\n"
    "    pos.x += 1;\n"
    "    RGBA4 = convert_uchar4_sat_rte(255 * read_imagef(pIn, imageSampler, pos));\n"
    "\n"
    "    ushort4 RGBA = convert_ushort4(RGBA1) + convert_ushort4(RGBA2) + convert_ushort4(RGBA3) + convert_ushort4(RGBA4);\n"
    "    \n"
    "    // Take average color\n"
    "    RGBA = RGBA>>2;\n"
    "\n"
    "    uchar Y1 = ( (  66 * RGBA1.x + 129 * RGBA1.y +  25 * RGBA1.z + 128) >> 8) +  16;\n"
    "    uchar Y2 = ( (  66 * RGBA2.x + 129 * RGBA2.y +  25 * RGBA2.z + 128) >> 8) +  16;\n"
    "    uchar Y3 = ( (  66 * RGBA3.x + 129 * RGBA3.y +  25 * RGBA3.z + 128) >> 8) +  16;\n"
    "    uchar Y4 = ( (  66 * RGBA4.x + 129 * RGBA4.y +  25 * RGBA4.z + 128) >> 8) +  16;\n"
    "    \n"
    "    // Write Y Plane\n"
    "    pOutI420[uiYPlaneOffset]     = Y1;\n"
    "    pOutI420[uiYPlaneOffset + 1] = Y2;\n"
    "\n"
    "    uiYPlaneOffset += vDim.z;\n"
    "\n"
    "    pOutI420[uiYPlaneOffset]     = Y3;\n"
    "    pOutI420[uiYPlaneOffset + 1] = Y4;\n"
    "\n"
    "    // Write U Plane\n"
    "    __global uchar* pOutU = pOutI420 + vDim.z * vDim.w;"
    "    __global uchar* pOutV = pOutU + vDim.z * vDim.w / 2;"
    "    pOutU[uiGlobalIdX + uiGlobalIdY * vDim.z] = ( ( -38 * RGBA.x -  74 * RGBA.y + 112 * RGBA.z + 128) >> 8) + 128; \n"
    "    // Write V Plane\n"
    "    pOutV[uiGlobalIdX + uiGlobalIdY * vDim.z] = ( ( 112 * RGBA.x -  94 * RGBA.y -  18 * RGBA.z + 128) >> 8) + 128;\n"
    "}\n"
    "\n"
    "\n"
    "\n"
    "\n"
    "\n"
    "\n"
    "__kernel void copy_rgba_image2d(__read_only image2d_t rgbaIn, __global uchar *rgbaOut, const int4 vDim, const int mirror, const int nTargetOrdering)   \n"
    "{  \n"
    "   uint uiGlobalId_X = get_global_id(0);                               \n"
    "   uint uiGlobalId_Y = get_global_id(1);                               \n"
    "\n"
    "    if(uiGlobalId_X >= vDim.x || uiGlobalId_Y >= vDim.y)               \n"
    "        return;                                                        \n"
    "\n"
    "   int2 ImgCoord;                                                      \n"
    "\n"
    "   if (mirror)                                                         \n"
    "   {                                                                   \n"
    "      ImgCoord = (int2)(uiGlobalId_X, vDim.y - (uiGlobalId_Y + 1));    \n"
    "   } \n"
    "   else    \n"
    "   {       \n"
    "      ImgCoord = (int2)(uiGlobalId_X, uiGlobalId_Y);   \n"
    "   } \n"
    "\n"
    "   uint uiBufferOffset = (uiGlobalId_X + (uiGlobalId_Y * vDim.z )) * 4;    \n"
    "\n"
    "   uchar4 pixel = convert_uchar4_sat(255.0f * read_imagef(rgbaIn, imageSampler, ImgCoord));    \n"
    "\n"  
    "   if (nTargetOrdering == 1)   \n"
    "   {\n"
    "\n"
    "      // Write ARGB \n"
    "      rgbaOut[uiBufferOffset]     = pixel.w;  \n"
    "      rgbaOut[uiBufferOffset + 1] = pixel.x;  \n"
    "      rgbaOut[uiBufferOffset + 2] = pixel.y;  \n"
    "      rgbaOut[uiBufferOffset + 3] = pixel.z;  \n"
    "   }\n"
    "   else if (nTargetOrdering == 2)  \n"
    "   { \n"
    "      // Write BGRA \n"
    "      rgbaOut[uiBufferOffset]     = pixel.z; \n"
    "      rgbaOut[uiBufferOffset + 1] = pixel.y; \n"
    "      rgbaOut[uiBufferOffset + 2] = pixel.x; \n"
    "      rgbaOut[uiBufferOffset + 3] = pixel.w; \n"
    "   }\n"
    "   else  \n"
    "   { \n"
    "      // Write RGBA\n"
    "      rgbaOut[uiBufferOffset]     = pixel.x; \n"
    "      rgbaOut[uiBufferOffset + 1] = pixel.y; \n"
    "      rgbaOut[uiBufferOffset + 2] = pixel.z; \n"
    "      rgbaOut[uiBufferOffset + 3] = pixel.w; \n"
    "   }\n"
    "}  \n"
    "\n";
    